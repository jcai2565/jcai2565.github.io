---
layout: post
title: "Lab 9: Mapping"
categories:
---

## Type of Control 

For this lab, I chose to do **orientation** control by varying the setpoint in 15 degree intervals until we get to a setpoint of 360 degrees for the full rotation. This can guarantee good readings from the TOF because there is no risk of drastic movements causing the return laser to miss the sensor. However, the act of getting the robot to escape static friction over and over again is difficult and results in jerky controls. I ended up choosing this option because getting incorrect TOF readings sounded like a more difficult and insidious bug to sort through, whereas overcoming friction can be done by tuning our PID extesively.

After some tuning, I realized that it may be best to use a PD controller because the timeframe that the robot stops for is too short for an integral term to contribute. So after some tuning, I got the robot to spin mostly on an axis with Kp = 6, Kd = 2, shown below.

<center>
  <iframe width="560" height="315" src="https://www.youtube.com/embed/YRNa7f_J3mY?si=7Y_cb_PcSln365dS" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</center>

To make sure that the PID control was working, I took the PID data from the on-axis test:

<center>
  <img alt="test pid" src="/assets/photos/lab9/lab9_turn_test_pid.png" width="100%">
</center>

## Discussion of Error

With the use of so many sensors, it's important to discuss the potential errors arising from each one to understand how much error we should expect to see on our map.

For the TOF sensor, I was mostly worried about the TOF's accuracy at short ranges because I am using long mode for this lab. When I tested short mode in Lab 3, I found that the TOF sensor was amazingly accurate within +-5 mm within its documented range, so I was convinced enough that the error would be negligible at long distances since our grid is discretized to 1 ft = 304 mm. I did the same procedure as in Lab 3, holding up a ruler/making marks on the table at fixed distances, then seeing what the TOF outputs. The testing data showed that there was a **discrepancy of 20 mm, but only at near-zero distances**. This ends up being mostly negligible for our purposes because our testing locations are never that close to an obstacle.

<center>
  <img alt="dist1" src="/assets/photos/lab9/lab9_tof_testing.png" width="70%">
</center>

For the DMP, I wanted to see how much the sensor would drift, so I tested it by simply leaving the robot stationary and printing the DMP angles to serial. The results showed that the DMP would often start off and quickly drift to a small positive angle within a few seconds (5 seconds, in the test below). This poses an issue because during data collection I had told the robot to start immediately after I hit the reset button -- this likely means a good chunk of data collection happened during this drift in angle. This likely caused the effect in the graphs below, where each dataset seemed to have their map **shifted by a few degrees**, making the resulting map tilted.

<center>
  <img alt="dmp1" src="/assets/photos/lab9/lab9_dmp_drift_1.png" width="45%">
</center>

<center>
  <img alt="dmp2" src="/assets/photos/lab9/lab9_dmp_drift_2.png" width="45%">
</center>

A final source of error is the inaccuracy of the on-axis turn. While the on-axis turn worked perfectly on some tiles, on other lab tiles the robot would slip. For the ones that did slip, there may be missing gaps in the data (although that is hard to quantify as an error numerically). And for other trials, I took the tape off of my robot. While that removed the slipping problem, the robot would sometimes **drive to the end of the tile** during its turn, meaning that measurements could be off by ~1 foot. It was also because of this that I **neglected the translation from the robot-center frame to the TOF frame during my transformation matrix** -- since the location of the TOF does not really maintain constant and can't be tracked precisely due to the variable movement and slipping during the turn, I thought it would be better to account for it in our error and post-process the results.

Summming up all of our potential errors we get that the maximum error is ~5 mm (TOF) + ~304 mm (robot movement) + ~76 mm (TOF translation) for distance **~= 385 mm**. While the DMP angle is likely off by **~5 degrees**. I don't think I could quantify a distinct average error compared to maximum error because it seems like the sources of error are mostly constant (or rather they don't really oscillate in any meaningfully predictable way). The DMP offset can be post-corrected during data processing, and the distance error (due to its inconsistency) gives us an explanation for seemingly incorrect data points.


## Raw Data

At each point, I collected the data to make a polar plot, a PID control plot, and the resulting transformed into global frame, just for a sanity check.

At point **(-3, -2)**:
<center>
  <img alt="" src="/assets/photos/lab9/lab9_-3-2_polar.png" width="70%">
</center>

<center>
  <img alt="" src="/assets/photos/lab9/lab9_-3-2_pid.png" width="100%">
</center>

<center>
  <img alt="" src="/assets/photos/lab9/lab9_-3-2_global.png" width="100%">
</center>

At point **(0, 3)**:
<center>
  <img alt="" src="/assets/photos/lab9/lab9_03_polar.png" width="70%">
</center>

<center>
  <img alt="" src="/assets/photos/lab9/lab9_03_pid.png" width="100%">
</center>

<center>
  <img alt="" src="/assets/photos/lab9/lab9_03_global.png" width="100%">
</center>

At point **(5, -3)**:
<center>
  <img alt="" src="/assets/photos/lab9/lab9_5-3_polar.png" width="70%">
</center>

<center>
  <img alt="" src="/assets/photos/lab9/lab9_5-3_pid.png" width="100%">
</center>

<center>
  <img alt="" src="/assets/photos/lab9/lab9_5-3_global.png" width="100%">
</center>

At point **(5, 3)**:
<center>
  <img alt="" src="/assets/photos/lab9/lab9_53_polar.png" width="70%">
</center>

<center>
  <img alt="" src="/assets/photos/lab9/lab9_53_pid.png" width="100%">
</center>

<center>
  <img alt="" src="/assets/photos/lab9/lab9_53_global.png" width="100%">
</center>

## Transformation to Global Frame

The raw globally transformed data into world frame (simply combining the four above) is as follows:
<center>
  <img alt="global" src="/assets/photos/lab9/lab9_global.png" width="100%">
</center>

We can evidently see the effect of the DMP drift, since **each subsection of the global graph seems to be tilted** counterclockwise by a few degrees. This can be rectified by shifting the angle measurements in each section down by 5 degrees, which gives a straight rectilinear map like we expect:
<center>
  <img alt="global" src="/assets/photos/lab9/lab9_global_rectified_5deg.png" width="100%">
</center>

We can see the effects of our position error most clearly in the red at point (5, -3). It seems that all of the **red points are shifted down by a half foot**. This can also then be rectified in post, giving us a much nicer, final graph.

<center>
  <img alt="global" src="/assets/photos/lab9/lab9_global_rectified_both.png" width="100%">
</center>

## Drawing in Map Boundaries

With these points, we can draw in the rough map boundaries. Note that it seems like the orange and red datasets were angularly shifted by even more than the 5 degrees I rectified for, especially for the square boundary in the middle of our map. I mentally accounted for that fact by imagining the lines drawn by the orange and red to be rotated a few more degrees such that it closes the bounds drawn in black.

<center>
  <img alt="map" src="/assets/photos/lab9/lab9_map.png" width="100%">
</center>

The set of endpoints used for my line segments is given as follows:
```
# Map line segments to plot
segments = [
    # boundary
    ((6.5, -4.5), (1, -4.5)),
    ((6.5, -4.5), (6.5, 4.75)),
    ((-2, 4.75), (6.5, 4.75)),
    ((-2, 4.75), (-2, 0)),
    ((-5.5, 0), (-2, 0)),
    ((-5.5, 0), (-5.5, -4.5)),
    ((-5.5, -4.5), (-1, -4.5)),
    ((-1, -4.5), (-1, -2)),
    ((-1, -2), (1, -2)),
    ((1, -2), (1, -4.5)),
    # square
    ((2.5, 2), (4.5, 2)),
    ((4.5, 0), (4.5, 2)),
    ((2.5, 0), (4.5, 0)),
    ((2.5, 0), (2.5, 2)),
]
```

## Acknowledgements

- None specifically for this lab, but thanks to course staff for holding so many open hours so I could get this done!